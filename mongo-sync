#!/bin/bash

set -e           # exit on error
set -o pipefail  # trace ERR through pipes
set -o errtrace  # trace ERR through 'time command' and other functions
set -o errexit   # exit the script if any statement returns a non-true return value

function cleanup {
    echo "Cleaning up..."
    if [ -z ${TMPDIR+x} ] ; then
        echo -n
    else
        rm -rf $TMPDIR
        unset TMPDIR
    fi
    unset FROM_CREDENTIALS
    unset FROM_HOST
    unset FROM_PORT
    unset FROM_DB
    unset FROM_TUNNEL_ENABLED
    unset FROM_TUNNEL_CREDENTIALS
    unset FROM_TUNNEL_PORT
    unset TO_CREDENTIALS
    unset TO_HOST
    unset TO_PORT
    unset TO_DB
    unset TO_TUNNEL_ENABLED
    unset TO_TUNNEL_CREDENTIALS
    unset TO_TUNNEL_PORT
    unset TUNNEL_PORT
}

function error {
    local parent_lineno="$1"
    local message="$2"
    local code="${3:-1}"
    if [[ -n "$message" ]] ; then
        echo "Error on or near line ${parent_lineno}: ${message}; exiting with status ${code}"
    else
        echo "Error on or near line ${parent_lineno}; exiting with status ${code}"
    fi
    cleanup
    exit "${code}"
}
trap 'error ${LINENO}' ERR

function usage_error {
    echo mongo-sync: "$1"
    echo "usage: mongo-sync <from> <to>"
    echo ""
    exit
}

function config_not_found {
    echo "failed: '$1' not found, it needs to be in the same dir"
    echo "aborting..."
    echo ""
    exit
}

function parse_yaml {
   local prefix=$2
   local s='[[:space:]]*' w='[a-zA-Z0-9_]*' fs=$(echo @|tr @ '\034')
   sed -ne "s|^\($s\):|\1|" \
        -e "s|^\($s\)\($w\)$s:$s[\"']\(.*\)[\"']$s\$|\1$fs\2$fs\3|p" \
        -e "s|^\($s\)\($w\)$s:$s\(.*\)$s\$|\1$fs\2$fs\3|p"  "$1" |
   awk -F$fs '{
      indent = length($1)/2;
      vname[indent] = $2;
      for (i in vname) {if (i > indent) {delete vname[i]}}
      if (length($3) > 0) {
         vn=""; for (i=0; i<indent; i++) {vn=(vn)(vname[i])("_")}
         printf("%s%s%s=\"%s\"\n", "'$prefix'",vn, $2, $3);
      }
   }'
}

function get_script_dir {
    pushd . > /dev/null
    local SCRIPT_PATH="${BASH_SOURCE[0]}"

    if ([ -h "${SCRIPT_PATH}" ]) then
      while ([ -h "${SCRIPT_PATH}" ]) do cd `dirname "$SCRIPT_PATH"`; SCRIPT_PATH=`readlink "${SCRIPT_PATH}"`; done
    fi

    cd `dirname ${SCRIPT_PATH}` > /dev/null
    local SCRIPT_PATH=`pwd`;
    popd  > /dev/null

    echo $SCRIPT_PATH
}

function get_confirmation() {
    read -p "Are you sure you want to push data from $1 to $2? Enter 'yes': " mongo_confr

    case $mongo_confr in
        [yY][Ee][Ss] )  ;;
        *) echo "Incorrect input, aborting..."; exit;;
    esac
}

function load_configs {
    echo "load_configs"
    if [ -z "$CONFIG_FILE" ] ; then
        CONFIG_FILE="config.yml"
    fi
    local config=$CONFIG_FILE
    echo "Parsing '$config'..."

    DIR=$(get_script_dir)
    local FILE="$DIR/$config"

    if [ -f "$FILE" ]; then
       eval $(parse_yaml "$FILE")
       success_msg
    else
       config_not_found $config
    fi

    local from_access_username=$1_access_username
    local from_access_password=$1_access_password
    local from_host_url=$1_host_url
    local from_host_port=$1_host_port
    local from_db=$1_db
    local from_tunnel_on=$1_tunnel_on
    local from_tunnel_username=$1_tunnel_username
    local from_tunnel_port=$1_tunnel_port

    local to_access_username=$2_access_username
    local to_access_password=$2_access_password
    local to_host_url=$2_host_url
    local to_host_port=$2_host_port
    local to_db=$2_db
    local to_tunnel_on=$2_tunnel_on
    local to_tunnel_username=$2_tunnel_username
    local to_tunnel_port=$2_tunnel_port

    FROM_CREDENTIALS=""
    if [[ ! -z ${!from_access_username} ]] ; then
        FROM_CREDENTIALS="-u ${!from_access_username} -p ${!from_access_password}"
    fi

    FROM_HOST=${!from_host_url}
    FROM_PORT=${!from_host_port}
    FROM_DB=${!from_db}
    FROM_TUNNEL_ENABLED=${!from_tunnel_on}
    FROM_TUNNEL_CREDENTIALS="${!from_tunnel_username}@${!from_host_url}"
    FROM_TUNNEL_PORT=${!from_tunnel_port}

    TO_CREDENTIALS=""
    if [[ ! -z ${!to_access_username} ]] ; then
        TO_CREDENTIALS="-u ${!to_access_username} -p ${!to_access_password}"
    fi

    TO_HOST=${!to_host_url}
    TO_PORT=${!to_host_port}
    TO_DB=${!to_db}
    TO_TUNNEL_ENABLED=${!fto_tunnel_on}
    TO_TUNNEL_CREDENTIALS="${!fto_tunnel_username}@${!fto_host_url}"
    TO_TUNNEL_PORT=${!to_tunnel_port}

    TUNNEL_PORT=27018

    TMPDIR=/tmp/"$local_db"/dump
}

function banner {
    echo mongo-sync:
    echo -----------
}

function success_msg {
    echo "Success!"
    echo
}

function done_msg {
    echo "Done!"
    echo
}

function open_tunnel {
    echo "Connecting through SSH tunnel..."
    ssh -fqTNM -S db-sync-socket -L $TUNNEL_PORT:127.0.0.1:$2 $1 -p $3
}

function close_tunnel {
    echo "Disconnecting from SSH tunnel..."
    ssh -S db-sync-socket -O exit $1 2> /dev/null
}


function push {
    banner
    if [ "$3" == false ] ; then
        get_confirmation $1 $2
    fi
    load_configs $1 $2

    if [ "$FROM_TUNNEL_ENABLED" == true ] ; then
        open_tunnel $FROM_TUNNEL_CREDENTIALS $FROM_PORT $FROM_TUNNEL_PORT
        FROM_HOST="localhost"
        FROM_PORT=$TUNNEL_PORT
    fi

    echo "Dumping $1 DB to $TMPDIR... "
    mongodump \
        -h "$FROM_HOST":"$FROM_PORT" \
        -d "$FROM_DB" \
        $FROM_CREDENTIALS \
        --authenticationDatabase="admin" \
        -o "$TMPDIR" > /dev/null
    success_msg

    if [ "$FROM_TUNNEL_ENABLED" == true ] ; then
        close_tunnel $FROM_TUNNEL_CREDENTIALS
    fi

    if [ "$TO_TUNNEL_ENABLED" == true ] ; then
        open_tunnel $TO_TUNNEL_CREDENTIALS $TO_PORT $TO_TUNNEL_PORT
        TO_HOST="localhost"
        TO_PORT=$TUNNEL_PORT
    fi

    echo "Overwriting $2 DB with Dump... "
    mongorestore \
        -h "$TO_HOST":"$TO_PORT" \
        -d "$TO_DB" \
        $TO_CREDENTIALS \
        --authenticationDatabase="admin" \
        "$TMPDIR"/"$FROM_DB" --drop > /dev/null
    success_msg

    if [ "$TO_TUNNEL_ENABLED" == true ] ; then
        close_tunnel $TO_TUNNEL_CREDENTIALS
    fi

    cleanup
    done_msg
}

## MAIN
## ====

# TODO: Add --overwrite flag

POSITIONAL_ARGS=()
skip=false

while [[ $# -gt 0 ]]; do
  case $1 in
    -c|--config)
      if [ -e "$2" ] ; then
          CONFIG_FILE="$2"
      else
          usage_error "No config file named \"$2\""
      fi
      shift # past argument
      shift # past value
      ;;
     -y)
      skip=true
      shift # past argument
      ;;
    -*|--*)
      usage_error "Unrecognized option \"$1\""
      ;;
    *)
      POSITIONAL_ARGS+=("$1") # save positional arg
      shift # past argument
      ;;
  esac
done

set -- "${POSITIONAL_ARGS[@]}" # restore positional parameters

if [[ $# -lt 2 ]] ; then
    usage_error "Two arguments should be provided"
else
    from=$1
    to=$2
    push $from $to $skip
fi
